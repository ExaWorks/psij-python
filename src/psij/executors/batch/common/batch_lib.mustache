update_status() {
    STATUS="$1"

    ADDRS={{psij.us_addrs}}
    for ADDR in ${ADDRS//,/ }; do
        echo "{{job.id}} $STATUS" >/dev/udp/$ADDR/{{psij.us_port}}
    done
}

fail() {
    [ "{{psij.debug}}" != "0" ] && update_status "LOG Failing: $2"
    echo $2
    exit $1
}

check_remote() {
    SCHEME="$1"
    HOSTPORT="$2"

    if [ "$SCHEME" != "" ] && [ "$SCHEME" != "file" ]; then
        fail 121 "$SCHEME staging is not supported"
    fi
    if [ "$HOSTPORT" != "" ] && [ "$HOSTPORT" != "localhost" ]; then
        fail 121 "The host, if specified, must be \"localhost\". Got \"$HOSTPORT\"."
    fi
}

do_stagein() {
    SOURCE="$1"
    TARGET="$2"
    MODE="$3"
    SCHEME="$6"
    HOSTPORT="$7"

    check_remote "$SCHEME" "$HOSTPORT" || exit $?

    do_stage "$SOURCE" "$TARGET" "$MODE" 0
}

do_stage() {
    SOURCE="$1"
    TARGET="$2"
    MODE="$3"
    MISSING_OK="$4"

    [ "{{psij.debug}}" != "0" ] && update_status "LOG Stage $SOURCE -> $TARGET, mode: $MODE, missingok: $MISSING_OK"

    if [ ! -e "$SOURCE" ]; then
        if [ "$MISSING_OK" == "0" ]; then
            [ "{{psij.debug}}" != "0" ] && update_status "LOG Missing source file: $SOURCE"
            fail 121 "Missing source file: $SOURCE"
        else
            [ "{{psij.debug}}" != "0" ] && update_status "LOG Skipping staging of missing file $SOURCE"
            return 0
        fi
    fi

    [ "{{psij.debug}}" != "0" ] && update_status "LOG Staging $SOURCE to $TARGET"

    TARGET_DIR=`dirname "$TARGET"`

    if [ "$TARGET_DIR" != "" ]; then
        mkdir -p "$TARGET_DIR"
    fi

    if [ -d "$TARGET" ] && [ ! -d "$SOURCE" ]; then
        fail 121 "Target is a directory: $TARGET"
    fi

    if [ "$MODE" == "1" ]; then
        # copy
        cp -r -T "$SOURCE" "$TARGET" || fail 121 "Failed to copy \"$SOURCE\" to \"$TARGET\""
    elif [ "$MODE" == "2" ]; then
        # link
        {{!we want the same semantics as cp and mv, which is "overwrite if exists"}}
        {{!we resolve the source since it may be a path relative to the job dir}}
        rm -f "$TARGET"
        SOURCE=`readlink -m $SOURCE`
        ln -s "$SOURCE" "$TARGET"  || fail 121 "Failed to link \"$SOURCE\" to \"$TARGET\""
    elif [ "$MODE" == "3" ]; then
        # move
        mv -T -f "$SOURCE" "$TARGET" || fail 121 "Failed to move \"$SOURCE\" to \"$TARGET\""
    fi
}

_FLAG_IF_PRESENT=1
_FLAG_ON_SUCCESS=2
_FLAG_ON_ERROR=4
_FLAG_ON_CANCEL=8

do_stageout() {
    SOURCE="$1"
    TARGET="$2"
    MODE="$3"
    FLAGS="$4"
    FAILED="$5"
    SCHEME="$6"
    HOSTPORT="$7"

    check_remote "$SCHEME" "$HOSTPORT"

    [ "{{psij.debug}}" != "0" ] && update_status "LOG do_stageout $SOURCE -> $TARGET, mode: $MODE, flags: $FLAGS, failed: $FAILED"

    if [ "$FAILED" == "0" ] && [ "$((FLAGS & _FLAG_ON_SUCCESS))" != "0" ]; then
        do_stage "$SOURCE" "$TARGET" "$MODE" $((FLAGS & _FLAG_IF_PRESENT))
    elif [ "$FAILED" != "0" ] && [ "$((FLAGS & _FLAG_ON_ERROR))" != "0" ]; then
        do_stage "$SOURCE" "$TARGET" "$MODE" $((FLAGS & _FLAG_IF_PRESENT))
    fi
}

do_cleanup() {
    TARGET="$1"
    FAILED="$2"

    if [ "$FAILED" == "0" ] || [ "{{job.spec.cleanup_on_failure}}" != "0" ]; then

        TARGET=`readlink -m "$TARGET"`
        DIR=`readlink -m "{{job.spec.directory}}"`

        [ "{{psij.debug}}" != "0" ] && update_status "LOG Cleaning up $TARGET"

        case "$TARGET" in
            "$DIR"*)
                rm -rf "$TARGET"
                ;;
            *)
                fail 121 "Cannot clean $TARGET outside of job directory $DIR"
                ;;
        esac
    fi
}

stagein() {
    update_status STAGE_IN

{{#job.spec.stage_in}}
    do_stagein "{{source.path}}" "{{target}}" {{mode}} \
        "{{{source.scheme}}}" "{{#source.hostname}}{{{.}}}{{#source.port}}:{{{.}}}{{/source.port}}{{/source.hostname}}"
{{/job.spec.stage_in}}
}
